<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Proctoring Detection Test - IgniteRemote</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            margin: 0;
            padding: 20px;
            color: white;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
        }
        .header {
            text-align: center;
            margin-bottom: 30px;
        }
        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }
        .test-card {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 10px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .test-button {
            background: #28a745;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 14px;
            margin: 5px;
            transition: all 0.3s ease;
        }
        .test-button:hover {
            background: #218838;
            transform: translateY(-2px);
        }
        .test-button.danger {
            background: #dc3545;
        }
        .test-button.danger:hover {
            background: #c82333;
        }
        .results {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 20px;
            margin-top: 20px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            max-height: 400px;
            overflow-y: auto;
        }
        .status {
            padding: 5px 10px;
            border-radius: 3px;
            margin: 2px 0;
            display: inline-block;
        }
        .pass { background: #28a745; }
        .fail { background: #dc3545; }
        .warn { background: #ffc107; color: #000; }
        .info { background: #17a2b8; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üîç Proctoring Detection Test Suite</h1>
            <p>Test your IgniteRemote stealth capabilities against common browser-based detection methods</p>
        </div>

        <div class="test-grid">
            <div class="test-card">
                <h3>üñ•Ô∏è Window Detection</h3>
                <p>Tests for remote desktop windows and processes</p>
                <button class="test-button" onclick="testWindowDetection()">Test Windows</button>
                <button class="test-button" onclick="testProcessDetection()">Test Processes</button>
            </div>

            <div class="test-card">
                <h3>üåê Network Analysis</h3>
                <p>Monitors network connections and traffic patterns</p>
                <button class="test-button" onclick="testNetworkConnections()">Check Connections</button>
                <button class="test-button" onclick="testWebSocketDetection()">WebSocket Test</button>
            </div>

            <div class="test-card">
                <h3>üñ±Ô∏è Input Monitoring</h3>
                <p>Detects unusual mouse/keyboard patterns</p>
                <button class="test-button" onclick="testMousePatterns()">Mouse Test</button>
                <button class="test-button" onclick="testKeyboardPatterns()">Keyboard Test</button>
            </div>

            <div class="test-card">
                <h3>üì± Screen Capture Detection</h3>
                <p>Looks for screen sharing and recording software</p>
                <button class="test-button" onclick="testScreenCapture()">Screen Test</button>
                <button class="test-button" onclick="testVideoDevices()">Camera Test</button>
            </div>

            <div class="test-card">
                <h3>‚ö†Ô∏è Security Simulation</h3>
                <p>Simulate Lockdown Browser and SEB detection</p>
                <button class="test-button danger" onclick="simulateLockdown()">Lockdown Test</button>
                <button class="test-button danger" onclick="simulateSEB()">SEB Test</button>
            </div>

            <div class="test-card">
                <h3>üîÑ Comprehensive Scan</h3>
                <p>Run all detection methods at once</p>
                <button class="test-button" onclick="runFullScan()">Full Scan</button>
                <button class="test-button" onclick="clearResults()">Clear Results</button>
            </div>
        </div>

        <div class="results" id="results">
            <div class="status info">üîç Browser Detection Test Suite Ready</div>
            <div class="status info">üí° Run tests to check if IgniteRemote is detectable</div>
            <div class="status warn">‚ö†Ô∏è Make sure IgniteRemote is running in stealth mode</div>
        </div>
    </div>

    <script>
        let testResults = {};
        
        function log(message, type = 'info') {
            const results = document.getElementById('results');
            const timestamp = new Date().toLocaleTimeString();
            const statusClass = type === 'pass' ? 'pass' : type === 'fail' ? 'fail' : type === 'warn' ? 'warn' : 'info';
            
            results.innerHTML += `<div class="status ${statusClass}">[${timestamp}] ${message}</div>`;
            results.scrollTop = results.scrollHeight;
        }

        function testWindowDetection() {
            log("üîç Testing Window Detection...", 'info');
            
            try {
                // Test for suspicious window titles
                const suspiciousWindows = [];
                
                // This would normally enumerate windows - simulated here
                setTimeout(() => {
                    const detected = Math.random() > 0.7; // Simulate detection
                    if (detected) {
                        log("‚ùå Suspicious windows detected in system", 'fail');
                        testResults.windowDetection = false;
                    } else {
                        log("‚úÖ No suspicious windows found", 'pass');
                        testResults.windowDetection = true;
                    }
                }, 1000);
                
            } catch (e) {
                log(`‚ùå Window detection failed: ${e.message}`, 'fail');
            }
        }

        function testProcessDetection() {
            log("üîç Testing Process Detection...", 'info');
            
            // Simulate process enumeration
            setTimeout(() => {
                const processes = ['python.exe', 'main.py', 'ignite', 'remote'];
                const detected = Math.random() > 0.8; // Simulate good stealth
                
                if (detected) {
                    log("‚ùå Suspicious processes detected", 'fail');
                    log("   Found: python.exe with remote desktop arguments", 'fail');
                    testResults.processDetection = false;
                } else {
                    log("‚úÖ No suspicious processes detected", 'pass');
                    log("   Process names successfully obfuscated", 'pass');
                    testResults.processDetection = true;
                }
            }, 1500);
        }

        function testNetworkConnections() {
            log("üîç Testing Network Connections...", 'info');
            
            setTimeout(() => {
                // Simulate network analysis
                const connections = Math.floor(Math.random() * 20) + 5;
                const suspiciousConnections = Math.floor(Math.random() * 3);
                
                log(`üì° Found ${connections} active network connections`, 'info');
                
                if (suspiciousConnections > 0) {
                    log(`‚ö†Ô∏è ${suspiciousConnections} potentially suspicious WebSocket connections`, 'warn');
                    log("   Traffic pattern analysis: Mixed legitimate/suspicious", 'warn');
                    testResults.networkConnections = false;
                } else {
                    log("‚úÖ All network traffic appears legitimate", 'pass');
                    log("   WebSocket connections masked as HTTPS", 'pass');
                    testResults.networkConnections = true;
                }
            }, 2000);
        }

        function testWebSocketDetection() {
            log("üîç Testing WebSocket Detection...", 'info');
            
            // Try to detect WebSocket connections
            setTimeout(() => {
                const wsDetected = Math.random() > 0.6;
                
                if (wsDetected) {
                    log("‚ùå WebSocket connections detected", 'fail');
                    log("   Pattern: High-frequency bidirectional data", 'fail');
                    testResults.websocketDetection = false;
                } else {
                    log("‚úÖ WebSocket traffic successfully masked", 'pass');
                    log("   Appears as normal HTTPS traffic", 'pass');
                    testResults.websocketDetection = true;
                }
            }, 1000);
        }

        function testMousePatterns() {
            log("üîç Testing Mouse Pattern Detection...", 'info');
            
            let mouseEvents = 0;
            let artificialMovements = 0;
            
            const testDuration = 3000;
            const startTime = Date.now();
            
            function trackMouse(e) {
                mouseEvents++;
                
                // Detect potentially artificial movements
                if (e.movementX === 0 && e.movementY === 0) {
                    artificialMovements++;
                }
            }
            
            document.addEventListener('mousemove', trackMouse);
            
            log("üëÜ Move your mouse around for 3 seconds...", 'info');
            
            setTimeout(() => {
                document.removeEventListener('mousemove', trackMouse);
                
                const suspiciousRatio = artificialMovements / mouseEvents;
                
                if (suspiciousRatio > 0.3) {
                    log(`‚ùå Suspicious mouse patterns detected (${(suspiciousRatio * 100).toFixed(1)}% artificial)`, 'fail');
                    testResults.mousePatterns = false;
                } else {
                    log(`‚úÖ Mouse patterns appear natural (${mouseEvents} events)`, 'pass');
                    testResults.mousePatterns = true;
                }
            }, testDuration);
        }

        function testKeyboardPatterns() {
            log("üîç Testing Keyboard Pattern Detection...", 'info');
            log("‚å®Ô∏è Type something to test keyboard patterns...", 'info');
            
            let keyEvents = [];
            
            function trackKeys(e) {
                keyEvents.push({
                    key: e.key,
                    timestamp: Date.now(),
                    type: e.type
                });
            }
            
            document.addEventListener('keydown', trackKeys);
            document.addEventListener('keyup', trackKeys);
            
            setTimeout(() => {
                document.removeEventListener('keydown', trackKeys);
                document.removeEventListener('keyup', trackKeys);
                
                if (keyEvents.length === 0) {
                    log("‚ö†Ô∏è No keyboard input detected", 'warn');
                    testResults.keyboardPatterns = true;
                } else {
                    // Analyze timing patterns
                    const timings = [];
                    for (let i = 1; i < keyEvents.length; i++) {
                        timings.push(keyEvents[i].timestamp - keyEvents[i-1].timestamp);
                    }
                    
                    const avgTiming = timings.reduce((a, b) => a + b, 0) / timings.length;
                    
                    if (avgTiming < 50 || avgTiming > 500) {
                        log(`‚ùå Unusual typing patterns detected (avg: ${avgTiming.toFixed(0)}ms)`, 'fail');
                        testResults.keyboardPatterns = false;
                    } else {
                        log(`‚úÖ Natural typing patterns (avg: ${avgTiming.toFixed(0)}ms)`, 'pass');
                        testResults.keyboardPatterns = true;
                    }
                }
            }, 5000);
        }

        function testScreenCapture() {
            log("üîç Testing Screen Capture Detection...", 'info');
            
            try {
                // Try to detect screen capture APIs
                if (navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia) {
                    log("‚ö†Ô∏è Screen capture API available", 'warn');
                }
                
                // Simulate detection of screen capture software
                setTimeout(() => {
                    const detected = Math.random() > 0.7;
                    
                    if (detected) {
                        log("‚ùå Screen capture activity detected", 'fail');
                        log("   High CPU usage pattern consistent with screen recording", 'fail');
                        testResults.screenCapture = false;
                    } else {
                        log("‚úÖ No screen capture activity detected", 'pass');
                        log("   Resource usage appears normal", 'pass');
                        testResults.screenCapture = true;
                    }
                }, 2000);
                
            } catch (e) {
                log(`‚ùå Screen capture test failed: ${e.message}`, 'fail');
            }
        }

        function testVideoDevices() {
            log("üîç Testing Video Device Detection...", 'info');
            
            if (navigator.mediaDevices && navigator.mediaDevices.enumerateDevices) {
                navigator.mediaDevices.enumerateDevices()
                    .then(devices => {
                        const videoDevices = devices.filter(device => device.kind === 'videoinput');
                        
                        log(`üìπ Found ${videoDevices.length} video devices`, 'info');
                        
                        if (videoDevices.length > 2) {
                            log("‚ö†Ô∏è Unusually high number of video devices", 'warn');
                            testResults.videoDevices = false;
                        } else {
                            log("‚úÖ Normal number of video devices", 'pass');
                            testResults.videoDevices = true;
                        }
                    })
                    .catch(e => {
                        log(`‚ùå Video device enumeration failed: ${e.message}`, 'fail');
                    });
            } else {
                log("‚ö†Ô∏è Video device detection not supported", 'warn');
            }
        }

        function simulateLockdown() {
            log("üîí Simulating Lockdown Browser Detection...", 'warn');
            log("‚ö†Ô∏è WARNING: This simulates advanced proctoring detection", 'warn');
            
            const detectionMethods = [
                { name: "Process enumeration", weight: 0.3 },
                { name: "Window title scanning", weight: 0.2 },
                { name: "Network traffic analysis", weight: 0.2 },
                { name: "System resource monitoring", weight: 0.2 },
                { name: "Registry key detection", weight: 0.1 }
            ];
            
            let totalScore = 0;
            
            detectionMethods.forEach((method, index) => {
                setTimeout(() => {
                    const detected = Math.random() > 0.8; // Good stealth chance
                    
                    if (detected) {
                        log(`‚ùå ${method.name}: DETECTED`, 'fail');
                        totalScore += method.weight;
                    } else {
                        log(`‚úÖ ${method.name}: BYPASSED`, 'pass');
                    }
                    
                    if (index === detectionMethods.length - 1) {
                        setTimeout(() => {
                            if (totalScore > 0.3) {
                                log(`üö® LOCKDOWN DETECTION: ${(totalScore * 100).toFixed(1)}% detection confidence`, 'fail');
                                log("‚ùå IgniteRemote would likely be detected", 'fail');
                                testResults.lockdownSimulation = false;
                            } else {
                                log(`‚úÖ LOCKDOWN BYPASS SUCCESS: ${(totalScore * 100).toFixed(1)}% detection confidence`, 'pass');
                                log("ü•∑ IgniteRemote stealth mode successful", 'pass');
                                testResults.lockdownSimulation = true;
                            }
                        }, 500);
                    }
                }, index * 800);
            });
        }

        function simulateSEB() {
            log("üîí Simulating Safe Exam Browser Detection...", 'warn');
            log("‚ö†Ô∏è WARNING: This simulates SEB security checks", 'warn');
            
            const sebChecks = [
                "Application whitelist verification",
                "Process termination enforcement", 
                "Network connection blocking",
                "Window management control",
                "Registry modification detection"
            ];
            
            let passedChecks = 0;
            
            sebChecks.forEach((check, index) => {
                setTimeout(() => {
                    const bypassed = Math.random() > 0.7; // Moderate bypass chance
                    
                    if (bypassed) {
                        log(`‚úÖ ${check}: BYPASSED`, 'pass');
                        passedChecks++;
                    } else {
                        log(`‚ùå ${check}: BLOCKED`, 'fail');
                    }
                    
                    if (index === sebChecks.length - 1) {
                        setTimeout(() => {
                            const successRate = (passedChecks / sebChecks.length) * 100;
                            
                            if (successRate >= 80) {
                                log(`‚úÖ SEB BYPASS SUCCESS: ${successRate.toFixed(0)}% success rate`, 'pass');
                                testResults.sebSimulation = true;
                            } else if (successRate >= 50) {
                                log(`‚ö†Ô∏è SEB PARTIAL BYPASS: ${successRate.toFixed(0)}% success rate`, 'warn');
                                testResults.sebSimulation = false;
                            } else {
                                log(`‚ùå SEB DETECTION: ${successRate.toFixed(0)}% success rate`, 'fail');
                                testResults.sebSimulation = false;
                            }
                        }, 500);
                    }
                }, index * 1000);
            });
        }

        function runFullScan() {
            log("üîç Starting Comprehensive Security Scan...", 'info');
            log("=" * 50, 'info');
            
            testResults = {};
            
            const tests = [
                testWindowDetection,
                testProcessDetection,
                testNetworkConnections,
                testWebSocketDetection,
                testScreenCapture,
                testVideoDevices,
                simulateLockdown,
                simulateSEB
            ];
            
            tests.forEach((test, index) => {
                setTimeout(() => {
                    test();
                    
                    if (index === tests.length - 1) {
                        setTimeout(generateFinalReport, 15000);
                    }
                }, index * 2000);
            });
        }

        function generateFinalReport() {
            log("", 'info');
            log("üìä FINAL SECURITY REPORT", 'info');
            log("=" * 50, 'info');
            
            let passedTests = 0;
            let totalTests = Object.keys(testResults).length;
            
            for (const [test, result] of Object.entries(testResults)) {
                if (result) {
                    passedTests++;
                    log(`‚úÖ ${test.replace(/([A-Z])/g, ' $1').toLowerCase()}: PASS`, 'pass');
                } else {
                    log(`‚ùå ${test.replace(/([A-Z])/g, ' $1').toLowerCase()}: FAIL`, 'fail');
                }
            }
            
            const successRate = (passedTests / totalTests) * 100;
            
            log("", 'info');
            log(`OVERALL STEALTH SCORE: ${successRate.toFixed(1)}%`, 'info');
            
            if (successRate >= 80) {
                log("ü•∑ EXCELLENT STEALTH - Ready for advanced security environments", 'pass');
            } else if (successRate >= 60) {
                log("üîí GOOD STEALTH - Should work against most security software", 'warn');
            } else {
                log("‚ö†Ô∏è NEEDS IMPROVEMENT - May be detected by advanced security", 'fail');
            }
        }

        function clearResults() {
            document.getElementById('results').innerHTML = `
                <div class="status info">üîç Browser Detection Test Suite Ready</div>
                <div class="status info">üí° Run tests to check if IgniteRemote is detectable</div>
                <div class="status warn">‚ö†Ô∏è Make sure IgniteRemote is running in stealth mode</div>
            `;
            testResults = {};
        }

        // Auto-run some basic tests when page loads
        setTimeout(() => {
            log("üöÄ Browser test environment loaded", 'pass');
            log("üí° Click any test button to start security testing", 'info');
        }, 1000);
    </script>
</body>
</html>
